Итак вот все готово, все файлы подготовлены, будем создавать простой сайт с личным кабинетом
Сайт landing, но с возможностью авторизации и регистрации для добавления комментариев в конце сайта
Для начала следует создать наш первый контроллер который будет отвчеать за начальную страницу, назовем его
MainController
> console make:controller MainController
По умолчанию консоль выдаст ошибку из-за отсутсвия необходимых пакетов и пространство имен
Как минимум необходимо установить пространство имен make
> composer req symfony/maker-bundle --dev
а так же устновить аннотации (роуты) для успешного редиректа по страницам
Далее снова выполним установку контороллера, теперь у нас есть главная страница!

После создания контроллера в нем будет основной роут и основная функция для вывода json файла
Можно сразу изменить роут на корень, а также изменить вывод контроллера, для этого нужно поменять return

return new Response("<h1>Hello</h1>");
Как для примера самый простой респонс

для интереса можно оставить еще один роут в этом контроллере для пасхалки, создадим еще один роут и еще одну
функцию для вывода информации.

/**
* @Route("/lol", name="lol")
*/

public function lol(){
	return new Response("<h1>SECRET</h1>")
}

так как на данный момент мы можем выводить html документ только в контроллере, необходимо использовать 
предпроцессор twig

>composer req twig

Для подключения предпроцессора с контроллера необходимо импользовтаь метод render который находится у
абстрактногоКонтроллера у которого наследуются все остальные контроллеры
return $this->render('base.html.twig') 

Для подключения базы данных в проект необходимо сначала скачать пакет orm, а затем настроить файл .env
> composer req orm
Про настройку .env читать в другой документации.

После подключения базы данных необходимо её создать
console doctrine:database:create - создастся базаданных с названием из файла .env
Если базаданных выдает ошибку доступа то необходимо либо на phpmyadmin, либо в бд в консоле выполнить
следующие запросы:
-> grant all privileges on *.* to 'user'@'localhost' identified by 'your_password';
-> flush privileges;

И так для успешного добавления в бд новых таблиц создадим сущность, через которую можно будет регулировать
данные в бд (связывать, манипулировать, контролировать)
>console make:entity

После создание сущности, базе данных необходимо сказать об этом, для этого созданы миграции
после ее выполнения, в бд создастся таблица со всеми полями, что и в сущности
>console make:migration
>console doctrine:migrations:migrate

Итак допустим мы хотим добавить новую запись в нашу базу данных, для этого сделаем новый контроллер
и в нем настроем роут, при переходе на который будет осуществляться заранее подготовленная запись

При его загрузке необходимо чтобы контроллер создавал новый экземпляр уже готов сущности, затем загружал
в него необходимые данные через set... методы. Затем запрашивал EntityManager у абстрактного контроллера
и через метод сохранения и передачи данных на сервер сохранял данные в бд

$entity = new Your_Entity();
$entyty->set_SomeMethods("blabla");

$entityManager = $this->getDoctrine()->getManager();
$entityManager->persist($entity);
$entityManager->flush();

и чтобы выводилась какая-нибудь информация об создании сделаем return под твиг как делалось раньше

После того как данные отправились в базу данных было бы неплохо их получить обратно
Для этого воспользуемся классом PostsRepository, который был создан одновременно с сущностью Posts
в контроллере PostsController отправим все данные из репозитория на twig, благодаря методам 
PostsRepository (ОБЯЗАТЕЛЬНО ПЕРЕДАТЬ В МЕТОД PostsRepository $postsrepository):
$allposts = $postsRepository->FindAll();
return $this->render("base.html.twig", [
"allposts" => $allposts]);

Допустим возникла ситуация в которой необходимо удалить некоторую запись из базы дынных, делать все будем как
обычно: Создадим новый контроллер или будем использовать уже существующий, создадим новый роут, но в его путь
добавим уникальный id, который будет использоваться для удаления из бд:
/**
* @Route ("/main/remove", name="remove")
* @param $id
* @param PostsRepository $postsRepository
* @return Response
**/

Создадим уникальный метод с названием имени роута, в нем объявим обязательной переменной "id" и PostsRepository
public function remove($id, PostsRepository $postsRepository)

В методе будем использовать метод поиска по id у репозитория ->find($id) и передачи его в новую переменную
Далее вызовем менеджер сущностей и вызовем у него вместо persist, remove и передадим в него объект
После обязательно выполним flush()
Под конец было бы неплохо сделать редирект на главную страницу, воспользуемся методом абстрактного контроллера:
return $this->redirect($this->generateUrl('main'))
и передадим в него название роута

Чтобы вызвать этот метод в twig сделаем ссылку по нажатию которой будет осуществляться переход на эту страницу
и выполнение удаления записи
href = "{{ path('remove', {id: posts.id}) }}"
 
Сообщения до обновления:
Чтобы сделать flash сообщения необходимо перед тем как будет осуществлен Response (редирект) выполнить метод
добавления этого сообщения, используя метод абстрактного контроллера addFlash:
$this->addFlash('type', 'lolkek');
указав при этом тип, по которому потом это сообщение будет вызываться в twig, и само сообщение
Теперь в twig при рендере из контроллера мы можем вызвать появление сообщения:
{% message in app.flashes("type") %}
{{ message }}
{% endfor %}

Формы

для того чтобы создавать формы будем использовать bin/console, но для начала необходимо загрузить 
валидатор и сами бандлы форм в проекте, а затем уже создавать сами формы:
> composer req form validator
> bin/console make:form
При выполнении команды нужно сначала указать имя формы а затем к какой сущности она будет привязана
После этого создасться наша форма, ее нужно будет подключить, для этого в контроллере сначала
инициализируем ее, передадим в переменную форму как класс ::class и сущность которую будет использовать форма
для отправкм внесенных в нее данных
$form = $this->createForm(NewPostType::class, $entity);
после чего необходимо отлавливать все исходящие request от пользователя, подключим к атрибутам основного метода
Request $request и будет с помощью абстрактного метода ловить request формы:
$form->handleRequest($request);

Далее для того чтобы метод добавления данных срабатывал только один раз необходимо проверять нажать ли кнопка 
submit у формы, делать мы это будем через if:
if ($form->isSubmitted()){
}
в теле if уже объявляем entityManager, и в него как обычно кидаем нашу сущность и желательно осуществить редирект
на новую страницу.

Изначально при создании формы у нее отсутствует кнопка submit, для того чтобы ее добавить перейдем в код формы,
и в переменную $builder, добавим новый c первым параметром - именем объекта формы, вторым - что добавляем, 
в нашем случае специфический класс SubmitType::class :
->add('save', SubmitType::class);

Если необходимо видоизменить форму через стили, то нужно добавить третий параметр в ->add, а именно в массиве указать
переменную attr, в которую передать массив атрибутов которые будут содержать те или иные компоненты:
->add("save", SubmitType::class, [
	"attr" => [
		"class" => "someClassInCss";
]]);

Также эту форму необходимо передать на рендер в twig, чтобы это сделать необходимо в render, закинуть саму форму
с методом $form.createView();
,а в twig вызвать ее через {{ form(form) }}

Аутентификация
Итак для успешной авторизации в систему как обычно обратимся к bin/console make:auth это нам позволит создать
систему безопасности которая будет описана в security.yaml в конфиг файлах проекта
Но перед тем как выполнять ту команду необходимо сначала создать сущность User, создавать будет не просто сущность
а защищенную сущность, благодаря:
> bin/console make:user
обязательно установив перед этим пакет security
> composer req security
Выполним создание системы безопасности:
> bin/console make:auth
а также:
> bin/console make:registration_form

